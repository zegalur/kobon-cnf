# This tool helps you find the best-fitting lines for the arrangements
# generated using the `gen.py` tool.
# Pavlo Savchuk 2025

import sys
sys.path.append('../line-order') 

import lineorder
import koboncnf

import subprocess
import threading
import signal
import scipy
import time
import copy
import sys
import ast
import os

from datetime import datetime


help_info = """This tool helps you find the best-fitting lines for the arrangements
generated by the `gen.py` tool.

You can add a parameters file to the `params/` folder to specify what 
parameters to try. These parameters will be passed to the 
`lineorder.find_lines(...)` call. The file name must match the corresponding 
file in the `res/` directory.

Format:

[
    {
        'param_1' : val_1,
        'param_2' : val_2,
        ...
    },
    
    ...
]

Make sure the line-order repository is copied to the parent directory."""

aparams_info = "    -U                -- Try only unique (no re-index or reorder)."

html_header = '''<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>{title}</title>
</head>

<style>
  .max {{
    background-color: lightgreen; 
  }}

  .entry {{
    width: 320px;
    display: inline-block;
    gap: 0; 
    padding: 0; 
    margin: 0;
    border: 1px solid lightgray;
  }}

  img {{
    width: 300px;
    height: 300px;
  }}

  .tab {{
    width: 300px;
    white-space: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    border: 1px solid #ccc;
  }}

  .params {{
    width: 300px;
    white-space: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    border: 1px solid #ccc;
  }}
</style>

<body>
'''

html_end = '''
</body>

</html>
'''

html_entry = '''
<div class="entry {style}">
    <p class="stats">Stats: {stats}</p>
    <p class="params">Parameters: {params}</p>
    <p class="tab">Table: {table}</p>
    <img src="{svg}" />
</div>
'''


def new_res(table, params, svg, tri_count, upper_bound):
    return { 
        'table' : copy.deepcopy(table), 
        'params' : copy.deepcopy(params), 
        'svg' : copy.deepcopy(svg),
        'tri_count' : tri_count,
        'upper_bound' : upper_bound,
    }


def gen_main(
        TMP_DIR,
        RES_DIR,
        FIT_DIR,
        params_str,
        
        line_count,
        mirrored,
        rotational_symmetry,
        missing_triangles,
        clear,
        ):

    print("(SciPy version {})".format(scipy.__version__))

    PARAMS_DIR = "params/"

    fit_filename = FIT_DIR + "kobon" + params_str + ".txt"
    html_filename = FIT_DIR + "kobon" + params_str + ".html"
    res_filename = koboncnf.get_res_filename(RES_DIR, params_str)
    params_filename = koboncnf.get_params_filename(PARAMS_DIR, params_str)

    res = []
    tabs = []
    params = [ {} ]

    unique_only = True if "-U" in sys.argv else False

    # ========================== Read the tables ============================ #

    if os.path.exists(res_filename):
        print("Tables found in `{}`. Reading...".format(res_filename))
        data_str = "[]"
        with open(res_filename, "r") as file:
          data_str = file.read()
        tabs = ast.literal_eval(data_str)
        print("...DONE")
    else:
        koboncnf.print_err("Can't find tables file `{}`.".format(res_filename))

    # ====================== Read the parameters file ======================= #

    if os.path.exists(params_filename):
        print("Parameters file found in `{}`. Reading...".format(params_filename))
        with open(params_filename, "r") as file:
          data_str = file.read()
          params = ast.literal_eval(data_str)
        print("...DONE")

    # ====================== Clear the data if needed ======================= #

    if clear:
        print("Deleting existing data...")
        if os.path.exists(fit_filename):
            os.remove(fit_filename)
        print("The file '{}' has been deleted.".format(fit_filename))

    # ======================= Read the previous data ======================== #

    if os.path.exists(fit_filename):
        cont = input("Previous results found. Continue? (y/Y/n/N):")
        if (len(cont) == 0) or (cont in "yY"):
          print("Reading previous data...")
          with open(fit_filename, "r") as file:
            data_str = file.read()
            res = ast.literal_eval(data_str)
            print("...DONE")
            print("Found {} previous result(s).".format(len(res)))
    
    startT = time.time()

    for tab in tabs:
        tab_printed = False

        N = len(tab)

        tset = []
        rtab = lineorder.reverse_order(tab)
        # TODO: remove -U (unique), add -A for all symmetries etc.
        #tab2 = reindex_table(reindex_table(tab, len(tab)), 2)
        #rtab2 = reverse_order(tab2)

        if unique_only:
          tset = [ tab ]
        else:
          if mirrored:
            tset = [ tab, rtab ]
          elif rotational_symmetry > 1:
            tset_1 = [ lineorder.reindex_table(tab, i + 1) 
                       for i in range((2*N) // rotational_symmetry) ]
            tset_2 = [ lineorder.reindex_table(rtab, i + 1) 
                       for i in range((2*N) // rotational_symmetry) ]
            tset = tset_1 + tset_2
          else:
            tset_1 = [ lineorder.reindex_table(tab, i + 1) for i in range(N) ]
            tset_2 = [ lineorder.reindex_table(rtab, i + 1) for i in range(N) ]
            #tset_3 = [ lineorder.reindex_table(tab2, i + 1) for i in range(N) ]
            #tset_4 = [ lineorder.reindex_table(rtab2, i + 1) for i in range(N) ]
            tset = tset_1 + tset_2 # + tset_3 + tset_4

        for p in params:
          params_printed = False

          for input_tab in tset:

            skip_this = False

            # Check if we already process this configuration:
            for r in res:
              #if koboncnf.tabs_to_str([r['table']]) == koboncnf.tabs_to_str([input_tab]):
              if r['table'] == input_tab:
                #if str(r['params']) == str(p):
                if r['params'] == p:
                  skip_this = True
                  break

            if skip_this:
              continue

            if not tab_printed:
              print("Current table:")
              print(koboncnf.tabs_to_str([tab]))
              tab_printed = True

            if not params_printed:
              print("\n    Trying params = {} ...\n".format(p))
              params_printed = True

            print("    New configuration found. Trying...")

            straightened_arrangement = lineorder.find_lines(
                input_tab, 
                rotational_symmetry = rotational_symmetry,
                mirrored = mirrored,
                **p
                )

            if straightened_arrangement['status'] == 'OK':
              result_lines = straightened_arrangement['lines']
              result_svg = lineorder.draw_lines(result_lines)

              if result_svg['status'] == 'OK':
              
                lines_arrangment_svg = result_svg['svg']
                svg_file = ("imgs/kobon" + params_str 
                            + "-res" + str(1 + len(res)) + ".svg")
                with open(FIT_DIR + svg_file, "w") as svg:
                    svg.write(result_svg['svg'])

                tri_count = len(result_svg['triangles'])
                upper_bound = result_svg['upper_bound']
                nr = new_res(input_tab, p, svg_file, tri_count, upper_bound)
                res.append(nr)

                print("        Results: ({} / {})".format(tri_count, upper_bound))

                # Write the res file.

                koboncnf.block_ctrl_c()
                print("        Updating...".format(fit_filename))
                try:
                  with open(fit_filename, "w") as file:
                    file.write(str(res))
                    print("        Results updated (`{}`).".format(fit_filename))
                  with open(html_filename, "w") as file:
                    file.write(html_header.format(title = params_str))
                    for r in res:
                      file.write(html_entry.format(
                          style = "norm" if (r['tri_count'] != r['upper_bound']) else "max",
                          stats = "{} / {}".format(r['tri_count'], r['upper_bound']),
                          params = str(r['params']),
                          table = koboncnf.tabs_to_str([r['table']]),
                          svg = r['svg'],
                          ))
                    file.write(html_end)
                    print("        HTML updated (`{}`).".format(html_filename))
                finally:
                  koboncnf.unblock_ctrl_c()
                    
    endT = time.time()
    print("Total running time: {} sec".format(endT - startT))
    maximal_count = 0
    for r in res:
        if r['tri_count'] == r['upper_bound']:
            maximal_count += 1
    print("Maximal: {}".format(maximal_count))
    print("EXIT")


# Run the tool:
koboncnf.run(
        gen_main, 
        script_name = "fit", 
        info_text = help_info, 
        additional_params = ["-U"],
        additional_params_info = aparams_info,
        )

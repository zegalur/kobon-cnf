# Kobon triangle problem - CNF model generator.
# Pavlo Savchuk 2025

import os
import tempfile
import shutil

from collections import Counter

# from: https://github.com/zegalur/line-order/blob/master/lineorder/utils.py
def reindex_table(table_in, new_first_row):
    N = len(table_in)
    if (new_first_row > N) or (new_first_row < 1):
        return None
    result = []
    for line_index, row in enumerate(table_in):
        new_row = []
        for index in row:
            new_row.append((N + index - new_first_row) % N + 1)
        if (line_index + 1) < new_first_row:
            new_row.reverse()
        result.append(new_row)
    result = result[-(N - new_first_row + 1):] + result[:(new_first_row - 1)]
    return result

# from: https://github.com/zegalur/line-order/blob/master/lineorder/utils.py
def reverse_order(tab):
    indx = lambda l: 1 if l==1 else (len(tab)-l+2)
    return [ 
            [ indx(l) for l in (tab[0] if r == 0 else tab[indx(r+1)-1][::-1]) ] 
        for r in range(len(tab)) ]

def remove_list_duplicates(seq):
    result = []
    for item in seq:
        if item not in result:
            result.append(item)
    return result


cnf_header = """c 
c ======================================================================
c Kobon triangle problem - CNF model:
c   Line count = {N}
c   Mirrored = {M}
c   Rotational symmetry = {S}
c   Lines with a missing triangle = {T}
c   Logically excluded = {E} (incl.symm. = {Es})
c Autogenerated by KobonCNF (GitHub: https://github.com/zegalur/kobon-cnf)
c ======================================================================
c 
c This CNF model represents all possible pseudo-line arrangements 
c (except for the logically excluded one) in which every finite,
c non-overlapping segment is an edge of a non-overlapping triangle - 
c except for segments with missing triangles.
c 
c Numbering:
c   Lines are enumerated from 1 to {N}.
c   Rows are enumerated from 1 to {N}.
c   Columns are enumerated from 1 to {N1}.
c 
c Variables:
c   G(r,i,j) - line `j` is immediately after line `i` in row `r`.
c   X(r,i,j) - line `j` is somewhere after line `j` in row `r`.
c   A(r,i,k) - line `i` is in the column `k` and row `r`.
c   Mk(r,i,j) - a segment `(i,j)` in line `r` is missing a triangle.
c 
c Unknowns:"""

hr = "\nc\nc ======================================================================"


def generate(
        line_count,
        cnf_filename,
        rotational_symmetry = 1,
        mirrored = False,
        missing_triangles = [],
        skip = [],
        generate_table = False,
        ):
    """Generates a CNF model for the Kobon triangle problem with the given 
    parameters or generates the resulting table using SAT-solver output.

    Arguments:
        `line_count` -- Number of straight lines (>= 3).
        `cnf_filename` -- Name of the CNF file to work with. \
            If `generate_table` is `False`, the generated CNF model will be \
            written to this file. If `generate_table` is `True`, this file \
            will be interpreted as the output of a SAT solver and used to \
            generate the corresponding table.
        `rotational_symmetry` -- Degree of rotational symmetry \
            (1 means no symmetry).
        `mirrored` -- Mirror symmetry (if `True` - skips the rot. symmetry). \
            Mirrored by (1 + N // 2, 2 + N // 2) pair (by a perpendicular  \
            line to the first line).
        `missing_triangles` -- A list of one-based line indices that can \
            lack a triangle. Repeated indices indicate a line with multiple \
            missing triangles.
        `skip` -- A list of arrangements that should be logically excluded.
        `generate_table` -- If `True`, the input file is interpreted as \
            SAT-solver output and used to generate the corresponding table.

    Returns a dictionary with the following keys:
        `status` -- One of `OK`, `ERROR`, or `UNSATISFIABLE`.
        `msg` -- Contains an error message if `status` is `ERROR`.
        `table` -- The generated table, if `generate_table` is `True` \
            and `status` is `OK`.
    """

    assert(line_count >= 3)
    assert(len(cnf_filename) > 0)

    result = { 'status': "OK" }

    if mirrored:
        rotational_symmetry = 1

    N = line_count
    ROT = rotational_symmetry
    MT = list(Counter([(r-1) for r in missing_triangles]).items())
    E = len(skip)

    # Unknowns:
    
    G = {} # G[(r,i,j)] = G(r+1, i+1, j+1)
    X = {} # X[(r,i,j)] = X(r+1, i+1, j+1)
    A = {} # A[(r,i,k)] = A(r+1, i+1, k+1)
    M = {} # M[(k,r,i,j)] = Mk(r+1, i+1, j+1)

    clauses = 0

    unknowns = 0
    def new_unknown(): 
        nonlocal unknowns
        unknowns += 1 
        return unknowns

    for r in range(N):
      for i in range(N):
        if r == i: continue
        for j in range(N):
          if r == j: continue
          if i == j: continue
          G[(r,i,j)] = new_unknown()
          X[(r,i,j)] = new_unknown()
        for k in range(N-1):
          A[(r,i,k)] = new_unknown()
    
    for r,c in MT:
      for k in range(c):
        for i in range(N):
          for j in range(N):
            if r == i: continue
            if r == j: continue
            if i == j: continue
            M[(k,r,i,j)] = new_unknown()

    # =========================== Generate Table ============================ #
    
    if generate_table:
        var_values = {}
        # Read the boolean values from the cnf file:
        with open(cnf_filename, "r") as file:
          for l in file:
            if l.startswith("s"): 
              if "UNSATISFIABLE" in l:
                result['status'] = "UNSATISFIABLE"
                result['table'] = []
                return result
              elif not ("SATISFIABLE" in l):
                result['status'] = "ERROR"
                result['msg'] = "Expecting `s SATISFIABLE`."
                return result
            if not l.startswith("v"):
                continue
            for t in l.split(" "):
              if t == "v": continue
              if t == "": continue
              v = int(t)
              var_values[abs(v)] = True if v > 0 else False
        # Convert boolean values into a proper table:
        tab = []
        for r in range(N):
            row = []
            first = r
            for i in range(N):
              if i == r: continue
              if var_values[A[(r,i,0)]]:
                first = i
                break
            if first == r:
                result['status'] = "ERROR"
                result['msg'] = ("Invalid boolean values. " 
                              + "Make sure the CNF file is for the same model.")
                return result
            row.append(first + 1)
            while first != r:
              j = first
              first = r
              for i in range(N):
                if i == j: continue
                if i == r: continue
                if var_values[G[(r,j,i)]]:
                  first = i
                  row.append(i + 1)
                  break
            tab.append(row)
        result['table'] = tab
        return result

    # ============================ Generate CNF ============================= #

    with open(cnf_filename, "w") as f:

        # =============================== At ================================ #

        f.write(hr)
        f.write("\nc Each row has all the other lines:")
        f.write("\nc   forall r,i!=r: exists k: A(r,i,k)")
        for r in range(N):
          for i in range(N):
            if i == r: continue
            f.write("\n")
            for k in range(N-1):
              f.write("{0} ".format(A[(r,i,k)]))
            f.write("0")
            clauses += 1

        f.write(hr)
        f.write("\nc Rows don't have duplicate entries:")
        f.write("\nc   forall r,i!=r,k: A(r,i,k) => forall j!=k: -A(r,i,j)")
        for r in range(N):
          for i in range(N):
            if i == r: continue
            for k in range(N-1):
              for j in range(N-1):
                if j == k: continue
                f.write("\n-{0} -{1} 0".format(A[(r,i,k)], A[(r,i,j)]))
                clauses += 1

        f.write(hr)
        f.write("\nc Connection between `A` (at) and `G` (immediately after):")
        f.write("\nc   1. A(r,i,k) AND A(r,j,k+1) => G(r,i,j)")
        f.write("\nc   2. A(r,i,k) AND G(r,i,j) => A(r,j,k+1)")
        f.write("\nc   3. G(r,i,j) AND A(r,j,k+1) => A(r,i,k)")
        for r in range(N):
          for i in range(N):
            if i == r: continue
            for j in range(N):
              for k in range(N-2):
                if j == r: continue
                if j == i: continue
                f.write("\n-{0} -{1} {2} 0".format(
                    A[(r,i,k)], A[(r,j,k+1)], G[(r,i,j)]))
                f.write("\n-{0} -{1} {2} 0".format(
                    A[(r,i,k)], G[(r,i,j)], A[(r,j,k+1)]))
                f.write("\n-{0} -{1} {2} 0".format(
                    G[(r,i,j)], A[(r,j,k+1)], A[(r,i,k)]))
                clauses += 3
 
        # ============================== Next =============================== #
        
        f.write(hr)
        f.write("\nc Only one line can be immediately after another:")
        f.write("\nc   G(r,i,j) => forall k!=j: -G(r,i,k)")
        for r in range(N):
          for i in range(N):
            for j in range(N):
              if i == r: continue
              if j == r: continue
              if j == i: continue
              for k in range(N):
                if k == r: continue
                if k == i: continue
                if k == j: continue
                f.write("\n-{0} -{1} 0".format(G[(r,i,j)], G[(r,i,k)]))
                clauses += 1

        f.write(hr)
        f.write("\nc Relation between `first` and `immediately after`:")
        f.write("\nc   1.  A(r,i,1) => forall j!={i,r}: -G(r,j,i)")
        f.write("\nc   2. -A(r,i,1) => exists j!={i,r}:  G(r,j,i)")
        for r in range(N):
          for i in range(N):
            if r == i: continue
            line = ""
            for j in range(N):
              if j == r: continue
              if j == i: continue
              f.write("\n-{0} -{1} 0".format(A[(r,i,0)], G[(r,j,i)]))
              clauses += 1
              line += "{0} ".format(G[(r,j,i)])
            if len(line) > 0:
              f.write("\n{0} {1}0".format(A[(r,i,0)], line))
              clauses += 1

        f.write(hr)
        f.write("\nc Relation between `last` and `immediately after`:")
        f.write("\nc   1.  A(r,i,N-1) => forall j!={i,r}: -G(r,i,j)")
        f.write("\nc   2. -A(r,i,N-1) => exists j!={i,r}:  G(r,i,j)")
        for r in range(N):
          for i in range(N):
            if r == i: continue
            line = ""
            for j in range(N):
              if j == r: continue
              if j == i: continue
              f.write("\n-{0} -{1} 0".format(A[(r,i,N-2)], G[(r,i,j)]))
              clauses += 1
              line += "{0} ".format(G[(r,i,j)])
            if len(line) > 0:
              f.write("\n{0} {1}0".format(A[(r,i,N-2)], line))
              clauses += 1

        # =========================== Missing =============================== #

        f.write(hr)
        f.write("\nc Exactly one is missing per `missing entry`")
        f.write("\nc and only finite segments can have a missing triangle:")
        f.write("\nc   1. Mk(r,i,j) => forall i',j': -Mk(r, i',j')")
        f.write("\nc   2. Mk(r,i,j) => G(r,i,j)")
        for r,c in MT:
          for k in range(c):
            l = ""
            for i in range(N):
              for j in range(N):
                if i == r: continue
                if j == r: continue
                if i == j: continue
                f.write("\n-{0} {1} 0".format(M[(k,r,i,j)], G[(r,i,j)]))
                clauses += 1
                l += "{0} ".format(M[(k,r,i,j)])
                for i2 in range(N):
                  for j2 in range(N):
                    if i2 == r: continue
                    if j2 == r: continue
                    if i2 == j2: continue
                    if (i2 == i) and (j2 == j): 
                      continue
                    f.write("\n-{0} -{1} 0".format(M[(k,r,i,j)], M[(k,r,i2,j2)]))
                    clauses += 1
          if l != "":
              f.write("\n" + l + "0")
              clauses += 1

        # ============================ After ================================ #

        f.write(hr)
        f.write("\nc X(r,i,j) (`j` somewhere after `i`) is total (connected):")
        f.write("\nc   forall r,i,j (i!=r, j!=r, i!=j): X(r,i,j) OR X(r,j,i)")
        for r in range(N):
          for i in range(N):
            for j in range(i+1, N):
              if i == r: continue
              if j == r: continue
              clauses += 1
              f.write("\n{0} {1} 0".format(X[(r,i,j)],X[(r,j,i)]))

        f.write(hr)
        f.write("\nc X(r,i,j) (`j` somewhere after `i`) is antisymmetric:")
        f.write("\nc   forall r,i,j (i!=r, j!=r, i!=j): X(r,i,j) => -X(r,j,i)")
        for r in range(N):
          for i in range(N):
            for j in range(i+1, N):
              if i == r: continue
              if j == r: continue
              clauses += 1
              f.write("\n-{0} -{1} 0".format(X[(r,i,j)],X[(r,j,i)]))

        f.write(hr)
        f.write("\nc X(r,i,j) (`j` somewhere after `i`) is transitive:")
        f.write("\nc   X(r,i,j) AND X(r,j,k) => X(r,i,k)")
        for r in range(N):
          for i in range(N):
            for j in range(N):
              for k in range(N):
                if i == r: continue
                if j == r: continue
                if k == r: continue
                if i == j: continue
                if i == k: continue
                if j == k: continue
                clauses += 1
                f.write("\n-{0} -{1} {2} 0".format(
                    X[(r,i,j)], X[(r,j,k)], X[(r,i,k)]))

        f.write(hr)
        f.write("\nc Relationship between `j somewhere after i`")
        f.write("\nc and `first` and `last` in a row:")
        f.write("\nc   1. A(r,i,  1) => forall j!=i: X(r,i,j)")
        f.write("\nc   2. A(r,i,N-1) => forall j!=i: X(r,j,i)")
        f.write("\nc   3. forall j!=i: X(r,i,j) => A(r,i,1)")
        f.write("\nc   4. forall j!=i: X(r,j,i) => A(r,i,N-1)")
        for r in range(N):
          for i in range(N):
            l_first = ""
            l_last = ""
            for j in range(N):
              if i == r: continue
              if j == r: continue
              if i == j: continue
              f.write("\n-{0} {1} 0".format(A[(r,i,  0)], X[(r,i,j)]))
              f.write("\n-{0} {1} 0".format(A[(r,i,N-2)], X[(r,j,i)]))
              clauses += 2
              l_first += "-{0} ".format(X[(r,i,j)])
              l_last += "-{0} ".format(X[(r,j,i)])
            if len(l_first) > 0:
              f.write("\n" + l_first + "{0} 0".format(A[(r,i,0)]))
              f.write("\n" + l_last + "{0} 0".format(A[(r,i,N-2)]))
              clauses += 2

        f.write(hr)
        f.write("\nc Connection between `j immediately after i` and `j after i`:")
        f.write("\nc   G(r,i,j) => X(r,i,j)")
        for r in range(N):
          for i in range(N):
            for j in range(N):
              if i == r: continue
              if j == r: continue
              if i == j: continue
              f.write("\n-{0} {1} 0".format(G[(r,i,j)], X[(r,i,j)]))
              clauses += 1

        # =========================== Triangles ============================= #

        """
        +---------------------------------+---------------------------------+
        |    \|              \  |         |    \|              \  |         |
        |     +           <---+-+---< r   |     +           <---+-+---< r   |
        |     |\               \|         |     |\               \|         |
        | <---+-+---< r         +         | <---+-+---< r         +         |
        |     |  \              |\        |     |  \              |\        |
        |     ^   ^             ^ ^       |     ^   ^             ^ ^       |
        |     j    i    (1)     j  i      |     i    j    (2)     i  j      |
        +---------------------------------+---------------------------------+
        |    \|              \  |         |    \|              \  |         |
        |     +           <---+-+---< i   |     +           <---+-+---< j   |
        |     |\               \|         |     |\               \|         |
        | <---+-+---< i         +         | <---+-+---< j         +         |
        |     |  \              |\        |     |  \              |\        |
        |     ^   ^             ^ ^       |     ^   ^             ^ ^       |
        |     j    r    (3)     j  r      |     i    r    (4)     i  r      |
        +---------------------------------+---------------------------------+
        |    \|              \  |         |    \|              \  |         |
        |     +           <---+-+---< i   |     +           <---+-+---< j   |
        |     |\               \|         |     |\               \|         |
        | <---+-+---< i         +         | <---+-+---< j         +         |
        |     |  \              |\        |     |  \              |\        |
        |     ^   ^             ^ ^       |     ^   ^             ^ ^       |
        |     r    j    (5)     r  j      |     r    i    (6)     r  i      |
        +---------------------------------+---------------------------------+
        """

        f.write(hr)
        f.write("\nc Every finite non-overlapping segment is an edge of")
        f.write("\nc a non-overlapping triangle, except for the segments")
        f.write("\nc with missing triangles:")
        f.write("\nc   Mk(r,i,j) OR (G(r,i,j) => G(i,{r,j}) AND G(j,{r,i}))")
        for r in range(N):
          for i in range(N):
            for j in range(N):
              if i == r: continue
              if j == r: continue
              if i == j: continue
              clauses += 4
              m_ij = ""
              m_ji = ""
              if (r+1) in missing_triangles:
                for k in range(c):
                  m_ij += "{0} ".format(M[(k,r,i,j)])
                  m_ji += "{0} ".format(M[(k,r,j,i)])
              if (r < i) and (i < j): # (1)
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,r,j)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,r,i)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,j,r)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,i,r)], m_ji))
              elif (r < j) and (j < i): # (2)
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,r,i)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,r,j)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,i,r)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,j,r)], m_ij))
              elif (i < r) and (r < j): # (3)
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,r,j)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,i,r)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,j,r)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,r,i)], m_ji))
              elif (j < r) and (r < i): # (4)
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,r,i)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,j,r)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,i,r)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,r,j)], m_ij))
              elif (i < j) and (j < r): # (5)
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,j,r)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,i,r)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,r,j)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,r,i)], m_ji))
              elif (j < i) and (i < r): # (6)
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(j,i,r)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,j,i)], G[(i,j,r)], m_ji))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(j,r,i)], m_ij))
                f.write("\n{2}-{0} {1} 0".format(G[(r,i,j)], G[(i,r,j)], m_ij))

        f.write(hr)
        f.write("\nc Every finite segment is an edge of triangle.")
        f.write("\nc This sets additional conditions for the X(r,i,j):")
        f.write("\nc   X(r,i,j) => X(i,{r,j}) AND X(j,{r,i})")
        for r in range(N):
          for i in range(N):
            for j in range(N):
              if i == r: continue
              if j == r: continue
              if i == j: continue
              clauses += 4
              if (r < i) and (i < j): # (1)
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,r,j)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,r,i)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,j,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,i,r)]))
              elif (r < j) and (j < i): # (2)
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,r,i)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,r,j)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,i,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,j,r)]))
              elif (i < r) and (r < j): # (3)
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,r,j)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,i,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,j,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,r,i)]))
              elif (j < r) and (r < i): # (4)
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,r,i)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,j,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,i,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,r,j)]))
              elif (i < j) and (j < r): # (5)
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,j,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,i,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,r,j)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,r,i)]))
              elif (j < i) and (i < r): # (6)
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(j,i,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,j,i)], X[(i,j,r)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(j,r,i)]))
                f.write("\n-{0} {1} 0".format(X[(r,i,j)], X[(i,r,j)]))

        # ============================ Mirror =============================== #

        if mirrored:
            f.write(hr)
            f.write("\nc Mirror symmetry:")
            f.write("\nc   (first) A(0,i,k) => A(0, N-i, N-2-k) (zero-based)")
            f.write("\nc   (other) A(r,i,k) => A(N-r, N-i mod N, k) (zero-based)")
            # First Line:
            for k in range(N-1):
              for i in range(N):
                if i == 0: continue
                f.write("\n-{0} {1} 0".format(A[(0,i,k)], A[(0,N-i,N-2-k)]))
                clauses += 1
            # Other Lines:
            for r in range(1, N):
              for k in range(N-1):
                for i in range(N):
                  if i == r: continue
                  f.write("\n-{0} {1} 0".format(A[(r,i,k)], A[(N-r,(N-i)%N,k)]))
                  clauses += 1
                
        # ========================= Rot. Symmetry =========================== #

        if rotational_symmetry > 1:
            P = (2*N) // ROT
            f.write(hr)
            f.write("\nc Rotational Symmetry (R{0}):\n".format(ROT))
            f.write("\nc   A(r,i,k) => A(sr,si,ik)")
            for r in range(N):
              for k in range(N-1):
                for i in range(N):
                  if i == r: continue
                  for j in range(1, ROT):
                    pr = r + j*P
                    sr = pr % N
                    si = (i + j*P) % N
                    sk = k if (pr < N) or (pr >= 2*N) else (N-2-k)
                    clauses += 1
                    f.write("\n-{0} {1} 0".format(A[(r,i,k)], A[(sr,si,sk)]))

        # ============================ Skip ================================= #

        if len(skip) > 0:
            f.write(hr)
            f.write("\nc Logically excluded arrangements (including symmetrical):")
            tmp = skip
            skip = []
            for b in tmp:
              rb = reverse_order(b)
              for i in range(len(b)):
                skip.append(reindex_table(b, i + 1))
                skip.append(reindex_table(rb, i + 1))
            skip = remove_list_duplicates(skip)
        for table in skip:
            line_1 = "\n"
            line_2 = "\n"
            for r in range(N):
              for i in range(N-1):
                line_1 += "-{0} ".format(A[(r,table[r][i]-1,i)])
                if i < (N-2):
                  line_2 += "-{0} ".format(G[(r,table[r][i]-1,table[r][i+1]-1)])
            line_1 += "0"
            line_2 += "0"
            f.write(line_1)
            #f.write(line_2)
            clauses += 1#2

    with tempfile.NamedTemporaryFile("w", delete=False) as temp:
        temp_name = temp.name

        # =========================== Header ================================ #

        temp.write(cnf_header.format(
                N = N, 
                N1 = N - 1,
                M = "True" if mirrored else "False",
                S = ROT,
                T = MT,
                git = "...",
                E = E,
                Es = len(skip),
                ))

        for r in range(N):
          for i in range(N):
            if r == i: continue
            for j in range(N):
              if r == j: continue
              if i == j: continue
              temp.write(
                    "\nc G({r},{i},{j}) = {g}\nc X({r},{i},{j}) = {x}".format(
                    r = r+1, i = i+1, j = j+1, g = G[(r,i,j)], x = X[(r,i,j)]))
            for k in range(N-1):
              temp.write("\nc A({r},{i},{k}) = {a}".format(
                    r = r+1, i = i+1, k = k+1, a = A[(r,i,k)]))
        
        for r,c in MT:
          for k in range(c):
            for i in range(N):
              for j in range(N):
                if r == i: continue
                if r == j: continue
                if i == j: continue
                temp.write("\nc M{k}({r},{i},{j}) = {m}".format(
                    k = k+1, r = r+1, i = i+1, j = j+1, m = M[(k,r,i,j)]))

        temp.write("\np cnf {0} {1}".format(unknowns, clauses))

        # Copy the original file content into the temp file:
        with open(cnf_filename, "r") as orig:
            shutil.copyfileobj(orig, temp)

    shutil.move(temp_name, cnf_filename)
    return result
